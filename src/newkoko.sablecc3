Package org.newkoko;

Helpers
    digit = ['0' .. '9'];
    not_digit =  ['_' + [['a' .. 'z'] + ['A' .. 'Z']]];
    lower_case = ['a' .. 'z'];
    tab = 9;
    cr = 13;
    lf = 10;
    eol = cr lf | cr | lf;
    blank = (' ' | tab | eol)+;

Tokens
    l_par = '(';
    r_par = ')';
    plus = '+';
    minus = '-';
    mul = '*';
    div = '/';
    semi = ';';
    int = 'int';
    double = 'double';
    identifier = lower_case (digit | not_digit)*;
    equals = '=';

    blank = blank;
    number = digit+ ('.' + digit+)?;
//    double_number = digit+ '.' + digit+;

Ignored Tokens
    blank;

Productions
    grammar           = statement_list                    {-> New grammar ([statement_list.statement])}
                      ;

    statement_list    {-> statement*} =
                        {list}    statement_list statement {-> [statement_list.statement, statement.statement] }
                      | {single}  statement {-> [statement.statement] }
                      ;

    statement         {-> statement} =
                        {assign_new_int} int identifier equals exp separator {-> New statement.assign_new_int (identifier, exp) } |
                        {assign_new_double} double identifier equals exp separator {-> New statement.assign_new_double (identifier, exp) } |
                        {assign} identifier equals exp separator {-> New statement.assign (identifier, exp) }
                       ;

    exp               {-> exp} =
                        {plus}    exp plus factor   {-> New exp.plus (exp.exp, factor.exp) }
                      | {minus}   exp minus factor  {-> New exp.minus (exp.exp, factor.exp) }
                      | {factor}  factor            {-> factor.exp }
                      ;

    factor            {-> exp} =
                        {mul}    factor mul term  {-> New exp.mul (factor.exp, term.exp) }
                      | {div}     factor div term   {-> New exp.div (factor.exp, term.exp) }
                      | {term}    term              {-> term.exp }
                      ;

    term              {-> exp} =
                        {number}  number            {-> New exp.number(number) }
                      | {exp}     l_par exp r_par   {-> exp.exp }
                      ;

    separator  {-> } =
                        {semicolon} semi {-> }
                      ;


Abstract Syntax Tree
    grammar           = statement+
                      ;

    statement         =
                        {assign_new_int}    identifier exp |
                        {assign_new_double} identifier exp |
                        {assign} identifier exp
                      ;

    exp               =
                        {plus}    [l]:exp  [r]:exp |
                        {minus}   [l]:exp  [r]:exp |
                        {div}     [l]:exp  [r]:exp |
                        {mul}    [l]:exp  [r]:exp |
                        {number}  number
                      ;